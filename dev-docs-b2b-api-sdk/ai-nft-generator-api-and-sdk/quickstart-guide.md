# QuickStart Guide

## QuickStart Guide: ChainGPT AI NFT Generator

Integrate AI-generated NFTs into your app in minutes. This guide walks you through getting an API key, setting up your environment, and creating your first AI-generated NFT using **either** the REST API or the JavaScript/TypeScript SDK. We‚Äôll cover both the immediate (synchronous) generation workflow and the queued (asynchronous) workflow for batch jobs, using BNB Chain Mainnet (chainId **56**) by default.

### Get Your API Key and Credits

Before coding, obtain an API key from the [ChainGPT Developer Dashboard](https://app.chaingpt.org/apidashboard) (in the ChainGPT web app under the SDK/API section). You may need to register and [purchase credits](https://app.chaingpt.org/addcredits) (each NFT generation request typically costs 1 credit). **Keep your API key secret** ‚Äì store it in an environment variable or secure config, not in your source code. You‚Äôll include this key in all API calls or SDK initialization.

{% hint style="info" %}
**Note:** Make sure your ChainGPT account has sufficient credits or an appropriate plan. NFT generation calls will fail if you run out of credits or if your API key is invalid.
{% endhint %}

***

### Option 1: Using the REST API (HTTP Endpoint)

The REST API allows you to integrate NFT generation via HTTP requests (great for backends or any language). You can test it with tools like **curl** or **Postman**. In each request, include your API key for authentication (e.g. as a Bearer token in the header).

#### Environment Setup for API Calls

No special SDK is needed. Ensure you have a tool to send HTTP requests:

* **curl** (command-line) or
* **Postman/Insomnia** (GUI) for testing.

In the examples below, we use `curl` in a shell. Replace `YOUR_API_KEY` with the API key from your dashboard.

#### 1. Generate an NFT Image + Metadata (Synchronous)

To generate an AI image and its NFT metadata in one step, make a **POST** request to the NFT generation endpoint. Include parameters like the text prompt, target model, and blockchain chainId in JSON. For example:

```bash
curl -X POST "https://api.chaingpt.org/v1/nft/generate" \
  -H "Authorization: Bearer YOUR_API_KEY" \
  -H "Content-Type: application/json" \
  -d '{
    "prompt": "A futuristic city skyline at sunset, digital art",
    "model": "velogen",
    "enhance": "1x",
    "steps": 2,
    "width": 1024,
    "height": 1024,
    "walletAddress": "YOUR_WALLET_ADDRESS", 
    "chainId": 56
  }'
```

* **prompt** ‚Äì The text description of the image you want (be creative!).
* **model** ‚Äì AI model to use (e.g. `"velogen"`).
* **enhance** ‚Äì (Optional) set `"1x"` or `"2x"` to upscale/improve image quality.
* **steps** ‚Äì (Optional) number of refinement steps (e.g. `2` for velogen, higher for other models).
* **width/height** ‚Äì Dimensions of the output image in pixels (e.g. 1024√ó1024).
* **walletAddress** ‚Äì The blockchain address that will receive the minted NFT.
* **chainId** ‚Äì Target blockchain network (here `56` for BNB Chain mainnet).

This request **generates the image and prepares the NFT data**. A successful response will return a JSON payload containing the generated image (as binary or a base64 string/URL) and a **`collectionId`** (an identifier for this generation job or NFT). You‚Äôll use the `collectionId` in the next step to mint the NFT on-chain.

{% hint style="info" %}
**Tip:** The `enhance` parameter can improve image resolution. Use it for higher quality outputs (supported by models like velogen, nebula\_forge\_xl, VisionaryForge). Keep in mind it may increase generation time and credit cost. For quick tests, you can omit it or use smaller resolutions.
{% endhint %}

#### 2. Mint the NFT on Chain

Generating an image does not automatically place it on the blockchain. To **mint** the AI-generated art as an actual NFT token, make a second request to the minting endpoint with the `collectionId` from the previous step. You can also specify a custom name, description, and symbol for your new NFT:

```bash
curl -X POST "https://api.chaingpt.org/v1/nft/mint" \
  -H "Authorization: Bearer YOUR_API_KEY" \
  -H "Content-Type: application/json" \
  -d '{
    "collectionId": "<COLLECTION_ID_FROM_GENERATE>",
    "name": "My First AI NFT",
    "description": "An NFT generated by ChainGPT AI",
    "symbol": "MYAI"
  }'
```

This will initiate an on-chain transaction to mint the NFT on the specified chain (BNB Chain in our example). The API will respond with the minting result, including details like the token ID and possibly a transaction hash or contract address. At this point, your NFT exists on-chain at the contract managed by ChainGPT‚Äôs NFT Generator, and is owned by the provided wallet address.

{% hint style="info" %}
**Note:** By default, if you don‚Äôt provide a custom name/description, the system generates a default name and metadata for the NFT. Providing your own can make your NFT more recognizable. The `symbol` usually represents the collection or contract symbol (e.g. ‚ÄúMYAI‚Äù); choose an appropriate 3-4 letter code.
{% endhint %}

#### 3. (Optional) Queued Asynchronous Generation for Batch Jobs

If you need to generate **many NFTs or an entire collection** in one go, or want to handle longer generation times without keeping a request open, you should use the **queued asynchronous flow**. In this mode, you submit a job and retrieve results later, which is ideal for bulk operations (hundreds or thousands of NFTs) or improving responsiveness in your app.

**Submit a generation job to the queue:**

```bash
curl -X POST "https://api.chaingpt.org/v1/nft/generate" \
  -H "Authorization: Bearer YOUR_API_KEY" \
  -H "Content-Type: application/json" \
  -d '{
    "prompt": "A series of 100 unique alien creature portraits, fantasy art",
    "model": "velogen",
    "width": 512,
    "height": 512,
    "walletAddress": "YOUR_WALLET_ADDRESS",
    "chainId": 56,
    "queue": true
  }'
```

By including `"queue": true` (or a similar async flag), the API will **immediately return** a response with a `collectionId` for your job, **without waiting** for all images to be generated. No images are returned yet in this immediate response.

You can then **poll the API for progress** using that `collectionId`. For example, call a progress endpoint to check status:

```bash
curl -X GET "https://api.chaingpt.org/v1/nft/progress?collectionId=<YOUR_COLLECTION_ID>" \
  -H "Authorization: Bearer YOUR_API_KEY"
```

This might return a status like `"pending"`, `"in_progress"`, and eventually `"completed"` along with maybe a percentage or count of images done. Once the job is completed (all NFTs generated and ready), you can retrieve the results (the generated images and metadata will be available via the API ‚Äì e.g. the final progress check might return the image URLs or data).

Finally, **mint the NFTs** on-chain. You could either mint each NFT individually by calling the mint endpoint for each one with the same `collectionId` and different names, or if the API supports batch minting, use that. In a simple case for one NFT, reuse the mint step above. For a large collection, you might loop over the results. For example, after completion:

```bash
# Example: Mint the first NFT from the completed collection
curl -X POST "https://api.chaingpt.org/v1/nft/mint" \
  -H "Authorization: Bearer YOUR_API_KEY" \
  -H "Content-Type: application/json" \
  -d '{
    "collectionId": "<YOUR_COLLECTION_ID>",
    "name": "Alien Creature #1",
    "description": "First NFT of my AI-generated alien collection",
    "symbol": "ALIEN"
  }'
```

In practice, you would iterate over all items in the collection. The key benefit of queuing is that your generation requests don‚Äôt timeout, and you can generate large batches in parallel. Use this mode when your use case involves heavy workloads or non-blocking UX (e.g. user requests 100 NFTs and you want to email them a link when ready, instead of holding a connection open).

{% hint style="info" %}
**Tip:** For queued jobs, automate your progress checking with a short interval (e.g. every 5-10 seconds) or use a webhook/callback if provided by ChainGPT‚Äôs API. This way, you can notify your users or trigger the next step (minting or displaying the NFTs) once generation is complete.
{% endhint %}

***

### Option 2: Using the JavaScript/TypeScript SDK

ChainGPT offers an official Node.js SDK (`@chaingpt/nft`) that wraps the above API calls into convenient functions. This is ideal for JavaScript projects (Node backends, web frameworks, or even front-end usage with bundlers) and provides TypeScript types for safer development. The SDK handles HTTP requests, file I/O, and data parsing under the hood.

#### 1. Installation and Setup

Make sure you have **Node.js** (and npm or yarn) installed in your environment. Initialize your project (e.g. run `npm init` in a new directory if needed), then install the ChainGPT NFT SDK package:

```bash
npm install --save @chaingpt/nft
# or
yarn add @chaingpt/nft
```

Once installed, import and configure the SDK with your API key:

```js
// Import the SDK class
const { Nft } = require('@chaingpt/nft');  // For ESM: import { Nft } from '@chaingpt/nft';
 
// Initialize the NFT generator client with your API key
const nftClient = new Nft({ apiKey: "YOUR_API_KEY" });
```

Now `nftClient` is ready to use. All SDK methods are asynchronous (return promises), so you‚Äôll typically call them inside an `async` function or use `.then()`.

#### 2. Generate and Mint an NFT (Synchronous Workflow)

Using the SDK, you can generate an image and then mint it with just a few lines of code. The SDK provides a `generateNft()` method to create the NFT art, and a `mintNft()` method to mint it on-chain. For example:

```js
const { Nft } = require('@chaingpt/nft');
const fs = require('fs');

const nft = new Nft({ apiKey: "YOUR_API_KEY" });

async function run() {
  // 2.a Generate an AI NFT image (and get metadata ready)
  const result = await nft.generateNft({
    prompt: "A mystical forest with glowing creatures, fantasy art",
    model: "velogen",
    enhance: "1x",
    steps: 2,
    width: 1024,
    height: 1024,
    walletAddress: "YOUR_WALLET_ADDRESS",
    chainId: 56
  });
  
  // The result contains the image data and a collectionId
  const collectionId = result.collectionId;
  // (Optional) Save the image to a file to verify the output
  fs.writeFileSync("generated_nft.jpg", Buffer.from(result.data.data));
  
  // 2.b Mint the generated image as an NFT on BNB Chain
  const mintInfo = await nft.mintNft({
    collectionId: collectionId,
    name: "Mystic Forest Creature",
    description: "An NFT generated by ChainGPT AI",
    symbol: "FOREST"
  });
  
  console.log("NFT minted! Details:", mintInfo);
}

run().catch(console.error);
```

Let‚Äôs break down what this does:

* `generateNft({...})` takes the same fields as the API call: prompt, model, image dimensions, etc., plus the target `walletAddress` and `chainId`. It returns an object containing the generated image (in `result.data`) and a `collectionId`. In this synchronous mode, the function only resolves when the image is fully generated (this might take \~30-60 seconds for a single high-res image). We write the image to `generated_nft.jpg` just as a quick check, but you could also directly use `result.data` (the image bytes or URL) in your application.
* `mintNft({...})` takes the returned `collectionId` and the NFT‚Äôs metadata (name, description, symbol) to finalize the mint. This will mint the NFT on-chain and return info about the newly minted token (for example, a token ID or transaction hash which `mintInfo` would contain).

After running this code, you should have an AI-generated image saved locally and an NFT minted on BNB Chain belonging to your wallet address. üéâ

{% hint style="info" %}
**Note:** The `generateNft()` method is ideal for on-demand creation of single NFTs or small batches. Under the hood, it‚Äôs a blocking call that covers image generation and prepares metadata. If the image generation fails or takes too long, it will throw an error (e.g., an `NftError`). Use try/catch (or `.catch`) to handle these gracefully in a real application.
{% endhint %}

#### 3. Asynchronous Batch Generation with Queue

For generating larger collections or when you don‚Äôt want to block your Node.js event loop, the SDK provides a **queue-based workflow**. Instead of waiting for each image, you enqueue a generation task and poll for its completion. The relevant methods are `generateNftWithQueue()` and `getNftProgress()`.

**Enqueue an NFT generation job:**

```js
// Enqueue the generation of multiple NFTs (e.g., a collection)
const job = await nft.generateNftWithQueue({
  prompt: "Abstract fractal art series, 10 variations",
  model: "nebula_forge_xl",
  width: 512,
  height: 512,
  walletAddress: "YOUR_WALLET_ADDRESS",
  chainId: 56
  // (other options like steps or enhance can be added as needed)
});

console.log("Job submitted. Collection ID:", job.collectionId);
```

The `generateNftWithQueue` call returns immediately with a job descriptor (including a `collectionId` for the queued task). The actual image generation happens asynchronously on ChainGPT‚Äôs servers.

**Check the generation progress:**

```js
// Later on... (you might poll every few seconds)
const status = await nft.getNftProgress({ collectionId: job.collectionId });
console.log("Generation status:", status.status, "-", status.progress);
```

The `getNftProgress()` method returns the current status of the job (e.g., _in\_progress_, _completed_) and possibly progress info (like how many images are done, or a percentage). You would call this periodically until you see a completed status. Once completed, the result images and metadata are ready.

**Mint the NFTs after completion:**

After the job is finished, you can mint the NFTs. If multiple NFTs were generated, you might loop through them; for simplicity, here‚Äôs how to mint one of the generated NFTs (using the same `collectionId`):

```js
const mintResult = await nft.mintNft({
  collectionId: job.collectionId,
  name: "Fractal Series #1",
  description: "Part of an AI-generated fractal art series",
  symbol: "FRACTAL"
});
console.log("Minted NFT from batch:", mintResult);
```

Each call to `mintNft` mints one token. You can provide different `name/description` for each, or reuse the prompt or default naming scheme. In a batch scenario, you might also use a loop or the data from the completed job to mint all NFTs in the collection.

{% hint style="info" %}
**Tip:** Use the asynchronous flow when you plan to generate more than a handful of NFTs or want to offload work from your application (for example, generating a 1000-NFT collection in parallel). The queue system is robust and will handle generation in the background. You can present a loading indicator to users and inform them when their NFT(s) are ready. For single or interactive NFT mints (like a user clicking ‚ÄúCreate NFT‚Äù in a UI), the direct `generateNft()` call is usually sufficient and simplest.
{% endhint %}

#### 4. Additional Features and Notes

* **Prompt Enhancement:** Not sure how to craft the perfect prompt? The API/SDK can help improve it. There‚Äôs an `enhancePrompt()` method that takes a simple prompt and returns a more detailed version. _Example:_ `await nft.enhancePrompt({ prompt: "a cat playing guitar" })` might return an enriched prompt like _‚ÄúA charming oil painting of a cat playing an acoustic guitar on a stage‚Äù_. This can be useful to guide users or to automatically boost prompt quality before generation.
* **Supported Models & Settings:** ChainGPT‚Äôs AI NFT Generator supports multiple models (e.g. `velogen`, `nebula_forge_xl`, `VisionaryForge`, `Dale3`) each with different style characteristics. You can experiment with them to get different art styles. Likewise, the `steps` parameter controls how many refinement iterations the model runs (higher can yield more detailed images but may take longer). The SDK‚Äôs README and docs have a full list of supported `model` options, image resolutions, and their compatible `enhance`/`steps` ranges.
* **Multi-Chain Support:** Our examples used `chainId: 56` (Binance Smart Chain mainnet). The NFT Generator supports **25+ blockchains** (Ethereum, Polygon, Arbitrum, Avalanche, Cronos, Tron, Base, opBNB, and more). To target a different network, simply change the `chainId` to the desired chain‚Äôs ID (for example, 1 for Ethereum mainnet, 137 for Polygon, etc.). If you‚Äôre unsure what chains are available or what their IDs are, you can fetch the list via the SDK‚Äôs `getChains()` method. For example: `const chains = await nft.getChains(false);` will return an array of supported mainnet chains (pass `true` to include testnets). You can then pick the chainId you need.
* **Security:** Whether using the API or SDK, treat your API key like a password. Do not expose it in client-side code or commit it to repos. In production, you‚Äôll likely route requests through your own backend that securely injects the API key. Also, ensure the wallet address you use for minting is correct ‚Äì once minted, the NFT will belong to that address on-chain. If it‚Äôs your user‚Äôs address, you might want to let them connect a wallet or provide it via your app‚Äôs UI.
* **Error Handling:** If an API call fails (network issue, invalid parameters, or insufficient credits), you‚Äôll get an error response. In the SDK, errors are thrown as `NftError` instances. Use try/catch around SDK calls in your code. Common mistakes include wrong API key, using an unsupported image size for the chosen model, or not having enough credits. The error messages from ChainGPT should help identify the issue.

***

You now have a solid starting point to integrate ChainGPT‚Äôs AI NFT Generator. With these examples, you can generate unique artwork from text prompts and trust ChainGPT to handle the heavy lifting of image generation and NFT minting across multiple blockchains. For more details, check out the full API reference and SDK documentation (which include deeper dives into response formats, advanced options, and best practices).&#x20;

**Happy building your AI-powered NFT experiences!**
